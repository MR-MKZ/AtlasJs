{"version":3,"file":"index.umd.js","sources":["../src/AtlasError.js","../src/extension.js","../src/index.js"],"sourcesContent":["class AtlasError extends Error {\r\n  constructor(message, type, tips, data) {\r\n    super(message);\r\n\r\n    this.name = \"AtlasError -> \" + type;\r\n    if (tips) {\r\n      this.tips = tips;\r\n    }\r\n    if (data) {\r\n      this.data = data;\r\n    }\r\n  }\r\n}\r\n\r\nexport function raiseError(message, type, tips, data) {\r\n  throw new AtlasError(message, type, tips, data);\r\n}\r\n","import { promises as fsPromises } from \"fs\";\r\nimport { raiseError } from \"./AtlasError.js\";\r\nimport { join, dirname } from 'path';\r\nimport { fileURLToPath } from 'url';\r\n\r\n\r\nfunction getFilePath(filename) {\r\n  try {\r\n    const __filename = fileURLToPath(import.meta.url);\r\n    const __dirname = dirname(__filename);\r\n    const filePath = join(__dirname, '..', 'assets', filename);\r\n    return filePath;\r\n  } catch (error) {\r\n    console.error('Error reading file:', error);\r\n  }\r\n}\r\n\r\nexport class AtlasFileReader {\r\n  constructor() {}\r\n\r\n  async getRegions() {\r\n    const data = await fsPromises.readFile(getFilePath(\"regions.json\"), \"utf8\");\r\n    return JSON.parse(data);\r\n  }\r\n\r\n  async getRegionByName(regName) {\r\n    if (isNaN(Number(regName))) {\r\n      const data = await fsPromises.readFile(getFilePath(\"regions.json\"), \"utf8\");\r\n      for (const region of JSON.parse(data)) {\r\n        if (region.name.toLowerCase() === regName.toLowerCase()) {\r\n          return region;\r\n        }\r\n      }\r\n      raiseError(`region ${regName} not found`, \"RESULT_NOT_FOUND\");\r\n    } else {\r\n      raiseError(\"region name must be string\", \"INPUT_TYPE_ERR\");\r\n    }\r\n  }\r\n\r\n  async getSubRegion(regionId) {\r\n    let subregions = [];\r\n    const data = await fsPromises.readFile(getFilePath(\"subregions.json\"), \"utf8\");\r\n    for (const subregion of JSON.parse(data)) {\r\n      if (subregion[\"region_id\"] == regionId) {\r\n        subregions.push(subregion);\r\n      }\r\n    }\r\n    if (subregions.length === 0) {\r\n      raiseError(\r\n        `Subregion with region id ${regionId} not found`,\r\n        \"RESULT_NOT_FOUND\"\r\n      );\r\n    } else {\r\n      return subregions;\r\n    }\r\n  }\r\n\r\n  async getCountries({\r\n    currency,\r\n    dialCode,\r\n    native,\r\n    nationality,\r\n    region,\r\n    subregion,\r\n    translations,\r\n    timezones,\r\n    geolocation,\r\n    emojies,\r\n    domain\r\n  }) {\r\n    let countries = [];\r\n    const data = await fsPromises.readFile(\r\n      getFilePath(\"countries_states_cities.json\"),\r\n      \"utf8\"\r\n    );\r\n    for (const country of JSON.parse(data)) {\r\n      let countryObj = {};\r\n      countryObj[\"id\"] = country[\"id\"];\r\n      countryObj[\"name\"] = country[\"name\"];\r\n      countryObj[\"iso2\"] = country[\"iso2\"];\r\n      countryObj[\"iso3\"] = country[\"iso3\"];\r\n      countryObj[\"capital\"] = country[\"capital\"];\r\n      if (dialCode) countryObj[\"phone_code\"] = country[\"phone_code\"];\r\n      if (currency) {\r\n        countryObj[\"currency\"] = country[\"currency\"];\r\n        countryObj[\"currency_name\"] = country[\"currency_name\"];\r\n        countryObj[\"currency_symbol\"] = country[\"currency_symbol\"];\r\n      }\r\n      if (domain) countryObj[\"domain\"] = country[\"tld\"];\r\n      if (native) countryObj[\"native\"] = country[\"native\"];\r\n      if (nationality) countryObj[\"nationality\"] = country[\"nationality\"];\r\n      if (region) {\r\n        countryObj[\"region\"] = country[\"region\"];\r\n        countryObj[\"region_id\"] = country[\"region_id\"];\r\n      }\r\n      if (subregion) {\r\n        countryObj[\"subregion\"] = country[\"subregion\"];\r\n        countryObj[\"subregion_id\"] = country[\"subregion_id\"];\r\n      }\r\n      if (translations) countryObj[\"translations\"] = country[\"translations\"];\r\n\r\n      if (timezones) countryObj[\"timezones\"] = country[\"timezones\"];\r\n\r\n      if (geolocation) {\r\n        countryObj[\"latitude\"] = country[\"latitude\"];\r\n        countryObj[\"longitude\"] = country[\"longitude\"];\r\n      }\r\n\r\n      if (emojies) {\r\n        countryObj[\"emoji\"] = country[\"emoji\"];\r\n        countryObj[\"emojiU\"] = country[\"emojiU\"];\r\n      }\r\n      countries.push(countryObj);\r\n    }\r\n    return countries;\r\n  }\r\n\r\n  async getStates({countryName, iso3, iso2, geolocation}) {\r\n    if (\r\n      (countryName !== undefined &&\r\n        countryName != null &&\r\n        isNaN(Number(countryName))) ||\r\n      (iso3 !== undefined && isNaN(Number(iso3))) ||\r\n      (iso2 !== undefined && isNaN(Number(iso2)))\r\n    ) {\r\n      let states = [];\r\n      const data = await fsPromises.readFile(\r\n        getFilePath(\"countries_states_cities.json\"),\r\n        \"utf8\"\r\n      );\r\n      for (const country of JSON.parse(data)) {\r\n        if (\r\n          (countryName !== undefined &&\r\n            countryName != null &&\r\n            country[\"name\"].toLowerCase() === countryName.toLowerCase()) ||\r\n          (iso3 !== undefined &&\r\n            country[\"iso3\"].toLowerCase() === iso3.toLowerCase()) ||\r\n          (iso2 !== undefined &&\r\n            country[\"iso2\"].toLowerCase() === iso2.toLowerCase())\r\n        ) {\r\n          for (const state of country[\"states\"]) {\r\n            let statesObj = {};\r\n            statesObj[\"id\"] = state[\"id\"];\r\n            statesObj[\"name\"] = state[\"name\"];\r\n            statesObj[\"state_code\"] = state[\"state_code\"];\r\n            if (geolocation) {\r\n              statesObj[\"latitude\"] = state[\"latitude\"];\r\n              statesObj[\"longitude\"] = state[\"longitude\"];\r\n            }\r\n            states.push(statesObj);\r\n          }\r\n        }\r\n      }\r\n      if (states.length === 0) {\r\n        raiseError(`Country ${countryName} not found`, \"RESULT_NOT_FOUND\", {\r\n          country_name: \"check entered country name: \" + countryName,\r\n          iso3: \"check entered iso3: \" + iso3,\r\n          iso2: \"check entered iso2: \" + iso2,\r\n        });\r\n      } else {\r\n        return states;\r\n      }\r\n    } else {\r\n      raiseError(\"region name must be string\", \"INPUT_TYPE_ERR\");\r\n    }\r\n  }\r\n\r\n  async getCities({countryName, stateName, geolocation}) {\r\n    let cities = [];\r\n    if (isNaN(Number(countryName)) && isNaN(Number(stateName))) {\r\n      const data = await fsPromises.readFile(\r\n        getFilePath(\"countries_states_cities.json\"),\r\n        \"utf8\"\r\n      );\r\n      let foundCountry = false;\r\n      let foundState = false;\r\n      for (const country of JSON.parse(data)) {\r\n        if (country[\"name\"].toLowerCase() === countryName.toLowerCase()) {\r\n          foundCountry = true;\r\n          for (const state of country[\"states\"]) {\r\n            if (state[\"name\"].toLowerCase() === stateName.toLowerCase()) {\r\n              foundState = true;\r\n              for (const city of state[\"cities\"]) {\r\n                let cityObj = {};\r\n                cityObj[\"id\"] = city[\"id\"];\r\n                cityObj[\"name\"] = city[\"name\"];\r\n                if (geolocation) {\r\n                  cityObj[\"latitude\"] = city[\"latitude\"];\r\n                  cityObj[\"longitude\"] = city[\"longitude\"];\r\n                }\r\n                cities.push(cityObj);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (cities.length > 0) {\r\n        return cities;\r\n      } else {\r\n        if (foundCountry) {\r\n          if (foundState) {\r\n            raiseError(`There is no city for ${countryName},${stateName}`, \"RESULT_NOT_FOUND\");\r\n          } else {\r\n            raiseError(`State ${stateName} not found`, \"RESULT_NOT_FOUND\", {\r\n              state: \"check entered state name: \" + stateName,\r\n            });\r\n          }\r\n        } else {\r\n          raiseError(`Country ${countryName} not found`, \"RESULT_NOT_FOUND\", {\r\n            country: \"check entered country name: \" + countryName,\r\n          });\r\n        }\r\n      }\r\n    } else {\r\n      raiseError(\r\n        \"country name and state name must be string\",\r\n        \"INPUT_TYPE_ERR\"\r\n      );\r\n    }\r\n  }\r\n}\r\n","import { AtlasFileReader } from \"./extension.js\";\r\nimport { raiseError } from \"./AtlasError.js\";\r\n\r\nconst atlasFileReader = new AtlasFileReader();\r\n\r\n/**\r\n * Returns a list of all regions.\r\n *\r\n * @returns {Promise<object>} A Promise that resolves to an array of regions.\r\n *\r\n * @example\r\n * // Returns list of all regions.\r\n * getAllRegions().then((regions) => {\r\n *   console.log(regions);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n */\r\nexport async function getAllRegions() {\r\n  return await atlasFileReader.getRegions();\r\n}\r\n\r\n/**\r\n * Returns subregions of a region.\r\n *\r\n * @param {string} region - The name of the region to get subregions for.\r\n * @returns {Promise<object>} A Promise that resolves to an array of subregions of the entered region.\r\n *\r\n * @example\r\n * // Returns list of subregions for Asia region.\r\n * getSubRegions(\"Asia\").then((subregions) => {\r\n *   console.log(subregions);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns INPUT_TYPE_ERR error.\r\n * getSubRegions(12).then((subregions) => {\r\n *   console.log(subregions);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns MISSING_REQUIRED_VALUE error.\r\n * getSubRegions().then((subregions) => {\r\n *   console.log(subregions);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n */\r\nexport async function getSubRegions(region) {\r\n  if (region && region !== undefined && region !== \"\") {\r\n    const foundRegion = await atlasFileReader.getRegionByName(region);\r\n    if (foundRegion !== undefined) {\r\n      let regionId = foundRegion.id;\r\n      return await atlasFileReader.getSubRegion(regionId);\r\n    }\r\n  } else {\r\n    raiseError(\"region name is required!\", \"MISSING_REQUIRED_VALUE\");\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a list of countries with optional additional information.\r\n *\r\n * @param {object} options - Options for the countries to retrieve.\r\n * @param {boolean} [options.currency] - Whether to include currency information.\r\n * @param {boolean} [options.dialCode] - Whether to include dial code information.\r\n * @param {boolean} [options.native] - Whether to include native information.\r\n * @param {boolean} [options.nationality] - Whether to include nationality information.\r\n * @param {boolean} [options.region] - Whether to include region information.\r\n * @param {boolean} [options.subregion] - Whether to include subregion information.\r\n * @param {boolean} [options.translations] - Whether to include translations information.\r\n * @param {boolean} [options.timezones] - Whether to include timezones information.\r\n * @param {boolean} [options.geolocation] - Whether to include geolocation information.\r\n * @param {boolean} [options.emojis] - Whether to include emojis information.\r\n * @param {boolean} [options.domain] - Whether to include domain information.\r\n * @returns {Promise<object>} A Promise that resolves to an array of countries with the requested information.\r\n *\r\n * @example\r\n * // Returns list of all countries.\r\n * getAllCountries().then((countries) => {\r\n *   console.log(countries);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n */\r\nexport async function getAllCountries({\r\n  currency,\r\n  dialCode,\r\n  native,\r\n  nationality,\r\n  region,\r\n  subregion,\r\n  translations,\r\n  timezones,\r\n  geolocation,\r\n  emojies,\r\n  domain\r\n}) {\r\n  return await atlasFileReader.getCountries({\r\n    currency,\r\n    dialCode,\r\n    native,\r\n    nationality,\r\n    region,\r\n    subregion,\r\n    translations,\r\n    timezones,\r\n    geolocation,\r\n    emojies,\r\n    domain\r\n  });\r\n}\r\n\r\n/**\r\n * This function gives you states of a country.\r\n *\r\n * @param {object} options - An object containing the country information\r\n * @param {string} options.country - Country name to get states\r\n * @param {string} options.iso3 - Country ISO3 to get states\r\n * @param {string} options.iso2 - Country ISO2 to get states\r\n * @param {boolean} [options.geolocation] - Do you want geolocation of each country state?\r\n * @returns {Promise<object>} A Promise that resolves to an array of country states with some special information if you want.\r\n *\r\n * @example\r\n * // Returns list of states for Iran.\r\n * getCountryStates({ country: \"iran\", geolocation: true }).then((states) => {\r\n *   console.log(states);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns list of states for IRN ISO3.\r\n * getCountryStates({ iso3: \"IRN\", geolocation: true }).then((states) => {\r\n *   console.log(states);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns list of states for IR ISO2.\r\n * getCountryStates({ iso2: \"IR\", geolocation: true }).then((states) => {\r\n *   console.log(states);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns INPUT_TYPE_ERR error.\r\n * getCountryStates({ country: 12, geolocation: true }).then((states) => {\r\n *   console.log(states);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns MISSING_REQUIRED_VALUE error.\r\n * getCountryStates({ geolocation: true }).then((states) => {\r\n *   console.log(states);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n */\r\nexport async function getCountryStates({country, iso3, iso2, geolocation}) {\r\n  if (\r\n    (country && country !== \"\") ||\r\n    (iso3 && iso3 !== \"\") ||\r\n    (iso2 && iso2 !== \"\")\r\n  ) {\r\n    if (country != null && country != undefined) {\r\n      country = country.toString();\r\n    }\r\n    if (iso3 != null && iso3 !== undefined) {\r\n      iso3 = iso3.toString();\r\n    }\r\n    if (iso2 != null && iso2 != undefined) {\r\n      iso2 = iso2.toString();\r\n    }\r\n    return await atlasFileReader.getStates({country, iso3, iso2, geolocation});\r\n  } else {\r\n    raiseError(\r\n      \"country name, iso3 or iso2 is missing, at least one of them is required!\",\r\n      \"MISSING_REQUIRED_VALUE\"\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * This function gives you cities of a state.\r\n *\r\n * @param {object} options - An object containing the state information\r\n * @param {string} options.country - Country name\r\n * @param {string} options.state - State name to get cities\r\n * @param {boolean} [options.geolocation] - Do you want geolocation of each state city?\r\n * @returns {Promise<object>} A Promise that resolves to an array of state cities with some special information if you want.\r\n *\r\n * @example\r\n * // Returns list of cities for Razavi Khorasan state of Iran.\r\n * getStateCities({ country: \"iran\", state: \"razavi khorasan\", geolocation: true }).then((cities) => {\r\n *   console.log(cities);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns INPUT_TYPE_ERR error.\r\n * getStateCities({ country: 12, state: \"\", geolocation: true }).then((cities) => {\r\n *   console.log(cities);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns MISSING_REQUIRED_VALUE error.\r\n * getStateCities({ country: \"\", state: \"\", geolocation: true }).then((cities) => {\r\n *   console.log(cities);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n */\r\nexport async function getStateCities({country, state, geolocation}) {\r\n  if (country && country !== undefined && country !== \"\") {\r\n    if (state && state !== undefined && state !== \"\") {\r\n      if (!isNaN(country)) country = country.toString();\r\n      if (!isNaN(state)) state = state.toString();\r\n\r\n      return await atlasFileReader.getCities({country, state, geolocation});\r\n    } else {\r\n      raiseError(\"state name is required!\", \"MISSING_REQUIRED_VALUE\");\r\n    }\r\n  } else {\r\n    raiseError(\"country name is required!\", \"MISSING_REQUIRED_VALUE\");\r\n  }\r\n}\r\n"],"names":["AtlasError","_Error","message","type","tips","data","_this","call","name","_wrapNativeSuper","Error","raiseError","getFilePath","filename","__filename","fileURLToPath","import","__dirname","dirname","join","error","console","atlasFileReader","AtlasFileReader","_proto","prototype","getRegions","Promise","resolve","fsPromises","readFile","then","JSON","parse","e","reject","getRegionByName","regName","isNaN","Number","_step","_iterator","_createForOfIteratorHelperLoose","done","region","value","toLowerCase","getSubRegion","regionId","subregions","_iterator2","_step2","subregion","push","length","getCountries","_ref","currency","dialCode","native","nationality","translations","timezones","geolocation","emojies","domain","countries","_step3","_iterator3","country","countryObj","getStates","_ref2","countryName","iso3","iso2","undefined","states","promises","_step4","_iterator4","_iterator5","_step5","state","statesObj","country_name","getCities","_ref3","stateName","cities","_step6","foundCountry","foundState","_iterator6","_step7","_iterator7","_iterator8","_step8","city","cityObj","toString","foundRegion","id"],"mappings":"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"}