{"version":3,"file":"index.esm.js","sources":["../src/AtlasError.js","../src/extension.js","../src/index.js"],"sourcesContent":["class AtlasError extends Error {\r\n  constructor(message, type, tips, data) {\r\n    super(message);\r\n\r\n    this.name = \"AtlasError -> \" + type;\r\n    if (tips) {\r\n      this.tips = tips;\r\n    }\r\n    if (data) {\r\n      this.data = data;\r\n    }\r\n  }\r\n}\r\n\r\nexport function raiseError(message, type, tips, data) {\r\n  throw new AtlasError(message, type, tips, data);\r\n}\r\n","import { promises as fsPromises } from \"fs\";\r\nimport { raiseError } from \"./AtlasError.js\";\r\nimport { join, dirname } from 'path';\r\nimport { fileURLToPath } from 'url';\r\n\r\n\r\nfunction getFilePath(filename) {\r\n  try {\r\n    const __filename = fileURLToPath(import.meta.url);\r\n    const __dirname = dirname(__filename);\r\n    const filePath = join(__dirname, '..', 'assets', filename);\r\n    return filePath;\r\n  } catch (error) {\r\n    console.error('Error reading file:', error);\r\n  }\r\n}\r\n\r\nexport class AtlasFileReader {\r\n  constructor() {}\r\n\r\n  async getRegions() {\r\n    const data = await fsPromises.readFile(getFilePath(\"regions.json\"), \"utf8\");\r\n    return JSON.parse(data);\r\n  }\r\n\r\n  async getRegionByName(regName) {\r\n    if (isNaN(Number(regName))) {\r\n      const data = await fsPromises.readFile(getFilePath(\"regions.json\"), \"utf8\");\r\n      for (const region of JSON.parse(data)) {\r\n        if (region.name.toLowerCase() === regName.toLowerCase()) {\r\n          return region;\r\n        }\r\n      }\r\n      raiseError(`region ${regName} not found`, \"RESULT_NOT_FOUND\");\r\n    } else {\r\n      raiseError(\"region name must be string\", \"INPUT_TYPE_ERR\");\r\n    }\r\n  }\r\n\r\n  async getSubRegion(regionId) {\r\n    let subregions = [];\r\n    const data = await fsPromises.readFile(getFilePath(\"subregions.json\"), \"utf8\");\r\n    for (const subregion of JSON.parse(data)) {\r\n      if (subregion[\"region_id\"] == regionId) {\r\n        subregions.push(subregion);\r\n      }\r\n    }\r\n    if (subregions.length === 0) {\r\n      raiseError(\r\n        `Subregion with region id ${regionId} not found`,\r\n        \"RESULT_NOT_FOUND\"\r\n      );\r\n    } else {\r\n      return subregions;\r\n    }\r\n  }\r\n\r\n  async getCountries({\r\n    currency,\r\n    dialCode,\r\n    native,\r\n    nationality,\r\n    region,\r\n    subregion,\r\n    translations,\r\n    timezones,\r\n    geolocation,\r\n    emojies,\r\n    domain\r\n  }) {\r\n    let countries = [];\r\n    const data = await fsPromises.readFile(\r\n      getFilePath(\"countries_states_cities.json\"),\r\n      \"utf8\"\r\n    );\r\n    for (const country of JSON.parse(data)) {\r\n      let countryObj = {};\r\n      countryObj[\"id\"] = country[\"id\"];\r\n      countryObj[\"name\"] = country[\"name\"];\r\n      countryObj[\"iso2\"] = country[\"iso2\"];\r\n      countryObj[\"iso3\"] = country[\"iso3\"];\r\n      countryObj[\"capital\"] = country[\"capital\"];\r\n      if (dialCode) countryObj[\"phone_code\"] = country[\"phone_code\"];\r\n      if (currency) {\r\n        countryObj[\"currency\"] = country[\"currency\"];\r\n        countryObj[\"currency_name\"] = country[\"currency_name\"];\r\n        countryObj[\"currency_symbol\"] = country[\"currency_symbol\"];\r\n      }\r\n      if (domain) countryObj[\"domain\"] = country[\"tld\"];\r\n      if (native) countryObj[\"native\"] = country[\"native\"];\r\n      if (nationality) countryObj[\"nationality\"] = country[\"nationality\"];\r\n      if (region) {\r\n        countryObj[\"region\"] = country[\"region\"];\r\n        countryObj[\"region_id\"] = country[\"region_id\"];\r\n      }\r\n      if (subregion) {\r\n        countryObj[\"subregion\"] = country[\"subregion\"];\r\n        countryObj[\"subregion_id\"] = country[\"subregion_id\"];\r\n      }\r\n      if (translations) countryObj[\"translations\"] = country[\"translations\"];\r\n\r\n      if (timezones) countryObj[\"timezones\"] = country[\"timezones\"];\r\n\r\n      if (geolocation) {\r\n        countryObj[\"latitude\"] = country[\"latitude\"];\r\n        countryObj[\"longitude\"] = country[\"longitude\"];\r\n      }\r\n\r\n      if (emojies) {\r\n        countryObj[\"emoji\"] = country[\"emoji\"];\r\n        countryObj[\"emojiU\"] = country[\"emojiU\"];\r\n      }\r\n      countries.push(countryObj);\r\n    }\r\n    return countries;\r\n  }\r\n\r\n  async getStates({countryName, iso3, iso2, geolocation}) {\r\n    if (\r\n      (countryName !== undefined &&\r\n        countryName != null &&\r\n        isNaN(Number(countryName))) ||\r\n      (iso3 !== undefined && isNaN(Number(iso3))) ||\r\n      (iso2 !== undefined && isNaN(Number(iso2)))\r\n    ) {\r\n      let states = [];\r\n      const data = await fsPromises.readFile(\r\n        getFilePath(\"countries_states_cities.json\"),\r\n        \"utf8\"\r\n      );\r\n      for (const country of JSON.parse(data)) {\r\n        if (\r\n          (countryName !== undefined &&\r\n            countryName != null &&\r\n            country[\"name\"].toLowerCase() === countryName.toLowerCase()) ||\r\n          (iso3 !== undefined &&\r\n            country[\"iso3\"].toLowerCase() === iso3.toLowerCase()) ||\r\n          (iso2 !== undefined &&\r\n            country[\"iso2\"].toLowerCase() === iso2.toLowerCase())\r\n        ) {\r\n          for (const state of country[\"states\"]) {\r\n            let statesObj = {};\r\n            statesObj[\"id\"] = state[\"id\"];\r\n            statesObj[\"name\"] = state[\"name\"];\r\n            statesObj[\"state_code\"] = state[\"state_code\"];\r\n            if (geolocation) {\r\n              statesObj[\"latitude\"] = state[\"latitude\"];\r\n              statesObj[\"longitude\"] = state[\"longitude\"];\r\n            }\r\n            states.push(statesObj);\r\n          }\r\n        }\r\n      }\r\n      if (states.length === 0) {\r\n        raiseError(`Country ${countryName} not found`, \"RESULT_NOT_FOUND\", {\r\n          country_name: \"check entered country name: \" + countryName,\r\n          iso3: \"check entered iso3: \" + iso3,\r\n          iso2: \"check entered iso2: \" + iso2,\r\n        });\r\n      } else {\r\n        return states;\r\n      }\r\n    } else {\r\n      raiseError(\"region name must be string\", \"INPUT_TYPE_ERR\");\r\n    }\r\n  }\r\n\r\n  async getCities({countryName, stateName, geolocation}) {\r\n    let cities = [];\r\n    if (isNaN(Number(countryName)) && isNaN(Number(stateName))) {\r\n      const data = await fsPromises.readFile(\r\n        getFilePath(\"countries_states_cities.json\"),\r\n        \"utf8\"\r\n      );\r\n      let foundCountry = false;\r\n      let foundState = false;\r\n      for (const country of JSON.parse(data)) {\r\n        if (country[\"name\"].toLowerCase() === countryName.toLowerCase()) {\r\n          foundCountry = true;\r\n          for (const state of country[\"states\"]) {\r\n            if (state[\"name\"].toLowerCase() === stateName.toLowerCase()) {\r\n              foundState = true;\r\n              for (const city of state[\"cities\"]) {\r\n                let cityObj = {};\r\n                cityObj[\"id\"] = city[\"id\"];\r\n                cityObj[\"name\"] = city[\"name\"];\r\n                if (geolocation) {\r\n                  cityObj[\"latitude\"] = city[\"latitude\"];\r\n                  cityObj[\"longitude\"] = city[\"longitude\"];\r\n                }\r\n                cities.push(cityObj);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (cities.length > 0) {\r\n        return cities;\r\n      } else {\r\n        if (foundCountry) {\r\n          if (foundState) {\r\n            raiseError(`There is no city for ${countryName},${stateName}`, \"RESULT_NOT_FOUND\");\r\n          } else {\r\n            raiseError(`State ${stateName} not found`, \"RESULT_NOT_FOUND\", {\r\n              state: \"check entered state name: \" + stateName,\r\n            });\r\n          }\r\n        } else {\r\n          raiseError(`Country ${countryName} not found`, \"RESULT_NOT_FOUND\", {\r\n            country: \"check entered country name: \" + countryName,\r\n          });\r\n        }\r\n      }\r\n    } else {\r\n      raiseError(\r\n        \"country name and state name must be string\",\r\n        \"INPUT_TYPE_ERR\"\r\n      );\r\n    }\r\n  }\r\n}\r\n","import { AtlasFileReader } from \"./extension.js\";\r\nimport { raiseError } from \"./AtlasError.js\";\r\n\r\nconst atlasFileReader = new AtlasFileReader();\r\n\r\n/**\r\n * Returns a list of all regions.\r\n *\r\n * @returns {Promise<object>} A Promise that resolves to an array of regions.\r\n *\r\n * @example\r\n * // Returns list of all regions.\r\n * getAllRegions().then((regions) => {\r\n *   console.log(regions);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n */\r\nexport async function getAllRegions() {\r\n  return await atlasFileReader.getRegions();\r\n}\r\n\r\n/**\r\n * Returns subregions of a region.\r\n *\r\n * @param {string} region - The name of the region to get subregions for.\r\n * @returns {Promise<object>} A Promise that resolves to an array of subregions of the entered region.\r\n *\r\n * @example\r\n * // Returns list of subregions for Asia region.\r\n * getSubRegions(\"Asia\").then((subregions) => {\r\n *   console.log(subregions);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns INPUT_TYPE_ERR error.\r\n * getSubRegions(12).then((subregions) => {\r\n *   console.log(subregions);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns MISSING_REQUIRED_VALUE error.\r\n * getSubRegions().then((subregions) => {\r\n *   console.log(subregions);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n */\r\nexport async function getSubRegions(region) {\r\n  if (region && region !== undefined && region !== \"\") {\r\n    const foundRegion = await atlasFileReader.getRegionByName(region);\r\n    if (foundRegion !== undefined) {\r\n      let regionId = foundRegion.id;\r\n      return await atlasFileReader.getSubRegion(regionId);\r\n    }\r\n  } else {\r\n    raiseError(\"region name is required!\", \"MISSING_REQUIRED_VALUE\");\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a list of countries with optional additional information.\r\n *\r\n * @param {object} options - Options for the countries to retrieve.\r\n * @param {boolean} [options.currency] - Whether to include currency information.\r\n * @param {boolean} [options.dialCode] - Whether to include dial code information.\r\n * @param {boolean} [options.native] - Whether to include native information.\r\n * @param {boolean} [options.nationality] - Whether to include nationality information.\r\n * @param {boolean} [options.region] - Whether to include region information.\r\n * @param {boolean} [options.subregion] - Whether to include subregion information.\r\n * @param {boolean} [options.translations] - Whether to include translations information.\r\n * @param {boolean} [options.timezones] - Whether to include timezones information.\r\n * @param {boolean} [options.geolocation] - Whether to include geolocation information.\r\n * @param {boolean} [options.emojis] - Whether to include emojis information.\r\n * @param {boolean} [options.domain] - Whether to include domain information.\r\n * @returns {Promise<object>} A Promise that resolves to an array of countries with the requested information.\r\n *\r\n * @example\r\n * // Returns list of all countries.\r\n * getAllCountries().then((countries) => {\r\n *   console.log(countries);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n */\r\nexport async function getAllCountries({\r\n  currency,\r\n  dialCode,\r\n  native,\r\n  nationality,\r\n  region,\r\n  subregion,\r\n  translations,\r\n  timezones,\r\n  geolocation,\r\n  emojies,\r\n  domain\r\n}) {\r\n  return await atlasFileReader.getCountries({\r\n    currency,\r\n    dialCode,\r\n    native,\r\n    nationality,\r\n    region,\r\n    subregion,\r\n    translations,\r\n    timezones,\r\n    geolocation,\r\n    emojies,\r\n    domain\r\n  });\r\n}\r\n\r\n/**\r\n * This function gives you states of a country.\r\n *\r\n * @param {object} options - An object containing the country information\r\n * @param {string} options.country - Country name to get states\r\n * @param {string} options.iso3 - Country ISO3 to get states\r\n * @param {string} options.iso2 - Country ISO2 to get states\r\n * @param {boolean} [options.geolocation] - Do you want geolocation of each country state?\r\n * @returns {Promise<object>} A Promise that resolves to an array of country states with some special information if you want.\r\n *\r\n * @example\r\n * // Returns list of states for Iran.\r\n * getCountryStates({ country: \"iran\", geolocation: true }).then((states) => {\r\n *   console.log(states);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns list of states for IRN ISO3.\r\n * getCountryStates({ iso3: \"IRN\", geolocation: true }).then((states) => {\r\n *   console.log(states);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns list of states for IR ISO2.\r\n * getCountryStates({ iso2: \"IR\", geolocation: true }).then((states) => {\r\n *   console.log(states);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns INPUT_TYPE_ERR error.\r\n * getCountryStates({ country: 12, geolocation: true }).then((states) => {\r\n *   console.log(states);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns MISSING_REQUIRED_VALUE error.\r\n * getCountryStates({ geolocation: true }).then((states) => {\r\n *   console.log(states);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n */\r\nexport async function getCountryStates({country, iso3, iso2, geolocation}) {\r\n  if (\r\n    (country && country !== \"\") ||\r\n    (iso3 && iso3 !== \"\") ||\r\n    (iso2 && iso2 !== \"\")\r\n  ) {\r\n    if (country != null && country != undefined) {\r\n      country = country.toString();\r\n    }\r\n    if (iso3 != null && iso3 !== undefined) {\r\n      iso3 = iso3.toString();\r\n    }\r\n    if (iso2 != null && iso2 != undefined) {\r\n      iso2 = iso2.toString();\r\n    }\r\n    return await atlasFileReader.getStates({country, iso3, iso2, geolocation});\r\n  } else {\r\n    raiseError(\r\n      \"country name, iso3 or iso2 is missing, at least one of them is required!\",\r\n      \"MISSING_REQUIRED_VALUE\"\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * This function gives you cities of a state.\r\n *\r\n * @param {object} options - An object containing the state information\r\n * @param {string} options.country - Country name\r\n * @param {string} options.state - State name to get cities\r\n * @param {boolean} [options.geolocation] - Do you want geolocation of each state city?\r\n * @returns {Promise<object>} A Promise that resolves to an array of state cities with some special information if you want.\r\n *\r\n * @example\r\n * // Returns list of cities for Razavi Khorasan state of Iran.\r\n * getStateCities({ country: \"iran\", state: \"razavi khorasan\", geolocation: true }).then((cities) => {\r\n *   console.log(cities);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns INPUT_TYPE_ERR error.\r\n * getStateCities({ country: 12, state: \"\", geolocation: true }).then((cities) => {\r\n *   console.log(cities);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n *\r\n * // Returns MISSING_REQUIRED_VALUE error.\r\n * getStateCities({ country: \"\", state: \"\", geolocation: true }).then((cities) => {\r\n *   console.log(cities);\r\n * }).catch((error) => {\r\n *   console.log(error);\r\n * })\r\n */\r\nexport async function getStateCities({country, state, geolocation}) {\r\n  if (country && country !== undefined && country !== \"\") {\r\n    if (state && state !== undefined && state !== \"\") {\r\n      if (!isNaN(country)) country = country.toString();\r\n      if (!isNaN(state)) state = state.toString();\r\n\r\n      return await atlasFileReader.getCities({country, state, geolocation});\r\n    } else {\r\n      raiseError(\"state name is required!\", \"MISSING_REQUIRED_VALUE\");\r\n    }\r\n  } else {\r\n    raiseError(\"country name is required!\", \"MISSING_REQUIRED_VALUE\");\r\n  }\r\n}\r\n"],"names":["AtlasError","_Error","message","type","tips","data","_this","call","name","_wrapNativeSuper","Error","raiseError","getFilePath","filename","__filename","fileURLToPath","url","__dirname","dirname","join","error","console","getStateCities","_ref3","country","state","geolocation","Promise","resolve","undefined","isNaN","toString","atlasFileReader","getCities","e","reject","getCountryStates","_ref2","iso3","iso2","getStates","getAllCountries","_ref","currency","dialCode","native","nationality","region","subregion","translations","timezones","emojies","domain","getCountries","getSubRegions","getRegionByName","then","foundRegion","getSubRegion","id","getAllRegions","getRegions","AtlasFileReader","_proto","prototype","fsPromises","readFile","JSON","parse","regName","Number","_step","_iterator","_createForOfIteratorHelperLoose","done","value","toLowerCase","regionId","subregions","_iterator2","_step2","push","length","countries","_step3","_iterator3","countryObj","countryName","states","_step4","_iterator4","_iterator5","_step5","statesObj","country_name","stateName","cities","_step6","foundCountry","foundState","_iterator6","_step7","_iterator7","_iterator8","_step8","city","cityObj"],"mappings":"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"}